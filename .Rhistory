ps.modelM <- glm(formula = formula(ps.formulaM), data=data, family=binomial)
summary(ps.modelM)
AIC(ps.modelM)
#stargazer(ps.modelM, type = "latex", title = "PS Marginal Model summary", summary = FALSE)
# propensity scores and ps-inverse weights computation
data$psM <- fitted(ps.modelM) # propensity scores
data$psMw <- with(data, ifelse(hybrid_teaching==1, 1/psM, 1/(1-psM)))
# distributions
with(data, by(psM, hybrid_teaching, summary))
with(data, by(psMw, hybrid_teaching, summary))
# add to prs_df
prs_df$psM = data$psM
prs_df$psMw = data$psMw
##### PS estimation : Random Effects Model (R) #####
ps.modelR <- glmer(formula = ps.formulaR, family = binomial(link="logit"),
data = data)
summary(ps.modelR)
# stargazer(ps.modelR, type = "latex", title = "PS Mixed-effects Model summary", summary = FALSE)
dotplot(ranef(ps.modelR))
# plot of the random intercept
jpeg(file="Images/dotplot_R.jpeg", width = 150, height = 150, units = 'mm', res = 250)
dp <- dotplot(ranef(ps.modelR), scales = list(x = list(relation = 'free')))
dp$stud_career_degree_name$main <- "GLMM - PS Estimation - PoliMi"
print(dp)
dev.off()
VPC = VarCorr(ps.modelR)[[1]][1]/(VarCorr(ps.modelR)[[1]][1] +pi^2/3)
VPC
# propensity scores and ps-inverse weights computation
data$psR = fitted(ps.modelR)
data$psRw <- with(data, ifelse(hybrid_teaching==1, 1/psR, 1/(1-psR)))
# distributions
with(data, by(psR, hybrid_teaching, summary))
with(data, by(psRw, hybrid_teaching, summary))
# add to prs_df
prs_df$psR = data$psR
prs_df$psRw = data$psRw
##### Some plots for the PS #####
##### FOR M #####
labs <- c("Hybrid", "Face-to-face")
PS_M = prs_df %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psM)) +
geom_histogram(aes(y = ..density..)) + ylim(0, 8) +
facet_wrap(~treatment) +
xlab("Propensity score - MLM - PoliMi")
ggsave("Images/PropensityScore_ModelM.jpeg", plot = PS_M, width = 8, height = 6)
# or
PS_M =prs_df %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psM, fill = treatment))+
geom_histogram(aes(y=..density..), color='gray50',
alpha=0.2, position = "identity")+ ylim(0, 8) +
geom_density(alpha=0.2) + theme(legend.position = "top") +
scale_fill_manual(values=c("cyan", "pink")) + labs(x='Propensity Score', fill='Delivered teaching type')
ggsave("Images/PropensityScore_ModelM.jpeg", plot = PS_M, width = 8, height = 5)
##### FOR R #####
PS_R = prs_df %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psR)) +
geom_histogram(aes(y = ..density..)) + ylim(0, 8) +
facet_wrap(~treatment) +
xlab("Propensity score - GLMM - PoliMi")
ggsave("Images/PropensityScore_ModelR.jpeg", plot = PS_R, width = 8, height = 6)
# or
PS_R = prs_df %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psR, fill = treatment))+
geom_histogram(aes(y=..density..), color='gray50',
alpha=0.2, position = "identity")+  ylim(0, 8) +
geom_density(alpha=0.2) +  theme(legend.position = "top") +
scale_fill_manual(values=c("cyan", "pink")) + labs(x='Propensity Score', fill='Delivered teaching type')
ggsave("Images/PropensityScore_ModelR.jpeg", plot = PS_R, width = 8, height = 5)
##### NOW FOR data_grade #####
# Dataframe with unit ID, treatment indicator, propensity scores and weights creation
prs_df_grade <- data.frame(data_grade$career_anonymous_id,
data_grade$hybrid_teaching,
data_grade$stud_career_degree_name)
prs_df_grade <- prs_df_grade %>% dplyr::rename(ID = data_grade.career_anonymous_id,
treatment = data_grade.hybrid_teaching)
##### PS estimation : Marginal Model (M) #####
# model fitting
ps.modelM <- glm(formula = formula(ps.formulaM), data=data_grade, family=binomial)
summary(ps.modelM)
AIC(ps.modelM)
stargazer(ps.modelM, type = "latex", title = "PS Marginal Model summary", summary = FALSE)
# propensity scores and ps-inverse weights computation
data_grade$psM <- fitted(ps.modelM) # propensity scores
data_grade$psMw <- with(data_grade, ifelse(hybrid_teaching==1, 1/psM, 1/(1-psM)))
# distributions
with(data_grade, by(psM, hybrid_teaching, summary))
with(data_grade, by(psMw, hybrid_teaching, summary))
# add to prs_df_grade
prs_df_grade$psM = data_grade$psM
prs_df_grade$psMw = data_grade$psMw
##### PS estimation : Random Effects Model (R) #####
ps.modelR <- glmer(formula = formula(ps.formulaR),
family = binomial(link="logit"),
data = data_grade)
summary(ps.modelR)
# stargazer(ps.modelR, type = "latex", title = "PS Mixed-effects Model summary", summary = FALSE)
VPC = VarCorr(ps.modelR)[[1]][1]/(VarCorr(ps.modelR)[[1]][1] +pi^2/3)
VPC
dotplot(ranef(ps.modelR))
# plot of the random intercept
jpeg(file="Images/dotplot_R_gpa.jpeg", width = 150, height = 150, units = 'mm', res = 250)
dp <- dotplot(ranef(ps.modelR), scales = list(x = list(relation = 'free')))
dp$stud_career_degree_name$main <- "GLMM - PS Estimation - PoliMi_GPA"
print(dp)
dev.off()
# propensity scores and ps-inverse weights computation
data_grade$psR = fitted(ps.modelR)
data_grade$psRw <- with(data_grade, ifelse(hybrid_teaching==1, 1/psR, 1/(1-psR)))
# distributions
with(data_grade, by(psR, hybrid_teaching, summary))
with(data_grade, by(psRw, hybrid_teaching, summary))
# add to prs_df_grade
prs_df_grade$psR = data_grade$psR
prs_df_grade$psRw = data_grade$psRw
##### Some plots for the PS #####
##### FOR M #####
labs <- c("Hybrid", "Face-to-face")
PS_M = prs_df_grade %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psM)) +
geom_histogram(aes(y = ..density..)) + ylim(0, 8) +
facet_wrap(~treatment) +
xlab("Propensity score - MLM - PoliMi_GPA")
ggsave("Images/PropensityScore_ModelM_gpa.jpeg", plot = PS_M, width = 8, height = 6)
PS_M = prs_df_grade %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psM, fill = treatment))+
geom_histogram(aes(y=..density..), color='gray50',
alpha=0.2, position = "identity")+  ylim(0, 8) +
geom_density(alpha=0.2) +  theme(legend.position = "top") +
scale_fill_manual(values=c("cyan", "pink")) + labs(x='Propensity Score', fill='Delivered teaching type')
ggsave("Images/PropensityScore_ModelM_gpa.jpeg", plot = PS_M, width = 8, height = 5)
##### FOR R #####
PS_R = prs_df_grade %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psR)) +
geom_histogram(aes(y = ..density..)) + ylim(0, 8) +
facet_wrap(~treatment) +
xlab("Propensity score - GLMM - PoliMi_GPA")
ggsave("Images/PropensityScore_ModelR_gpa.jpeg", plot = PS_R, width = 8, height = 5)
PS_R =prs_df_grade %>%
mutate(treatment = ifelse(treatment == 1, labs[1], labs[2])) %>%
ggplot(aes(x = psR, fill = treatment))+
geom_histogram(aes(y=..density..), color='gray50',
alpha=0.2, position = "identity")+  ylim(0, 8) +
geom_density(alpha=0.2) + theme(legend.position = "top") +
scale_fill_manual(values=c("cyan", "pink")) + labs(x='Propensity Score', fill='Delivered teaching type')
ggsave("Images/PropensityScore_ModelR_gpa.jpeg", plot = PS_R, width = 8, height = 5)
source('Utils_functions/import_libraries.R')
# apply weights to data
weighteddataM<-svydesign(ids = ~ 1, data = data, weights = ~ psMw)
weightedtableM <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataM, test = FALSE)
SMD_plot_Polimi_ECTS$Weighted_MLM = as.numeric(ExtractSmd(weightedtableM))
weighteddataR<-svydesign(ids = ~ 1, data = data, weights = ~ psRw)
weightedtableR <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataR, test = FALSE)
SMD_plot_Polimi_ECTS$Weighted_GLMM = as.numeric(ExtractSmd(weightedtableR))
weighteddataM_gr<-svydesign(ids = ~ 1, data = data_grade, weights = ~ psMw)
weightedtableM_gr <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataM_gr, test = FALSE)
SMD_plot_Polimi_GPA$Weighted_MLM = as.numeric(ExtractSmd(weightedtableM_gr))
weighteddataR_gr<-svydesign(ids = ~ 1, data = data_grade, weights = ~ psRw)
weightedtableR_gr <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataR_gr, test = FALSE)
SMD_plot_Polimi_GPA$Weighted_GLMM = as.numeric(ExtractSmd(weightedtableR_gr))
weightedtable <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataM, test = FALSE)
print(weightedtable, smd = TRUE) ## Show table with SMD
weightedtable <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataR, test = FALSE)
print(weightedtable, smd = TRUE) ## Show table with SMD
weightedtable <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataM_gr, test = FALSE)
print(weightedtable, smd = TRUE) ## Show table with SMD
weightedtable <-svyCreateTableOne(vars = covariateNames, strata = "hybrid_teaching",
data = weighteddataR_gr, test = FALSE)
print(weightedtable, smd = TRUE) ## Show table with SMD
#### MODEL FOR ECTS_cat - M ####
clmm_modM <- clmm(formula("ECTS_cat ~ admission_score + career_admission_age +
gender + previous_studies + origins + highschool_grade + hybrid_teaching +
(1 + hybrid_teaching|stud_career_degree_name)"),
control = clmm.control(innerCtrl = "noWarn"),
weights = data$psMw,
data=data)
source('Utils_functions/import_libraries.R')
source('Utils_functions/marginal_clustered_estimators.R')
R = 500
##### Create a table for the estimator (sd) #####
df <- matrix(NA, nrow=2, ncol = 4)
df <- cbind(c("M",  "R"), df)
colnames(df) <- c("PS Model", rep(c("Marginal", "Cluster-weighted"), 2))
df
a_header <- construct_header(
# the data.frame or matrix that should be plotted
df,
# the labels of the groups that we want to insert
grp_names = c("", "GPA", "ECTS"),
# the number of columns each group spans
span = c(1, 2, 2),
# the alignment of each group, can be a single character (lcr) or a vector
align = "c"
)
source('Utils_functions/marginal_clustered_estimators.R')
R = 500
##### Create a table for the estimator (sd) #####
df <- matrix(NA, nrow=2, ncol = 4)
df <- cbind(c("M",  "R"), df)
colnames(df) <- c("PS Model", rep(c("Marginal", "Cluster-weighted"), 2))
df
a_header <- construct_header(
# the data.frame or matrix that should be plotted
df,
# the labels of the groups that we want to insert
grp_names = c("", "GPA", "ECTS"),
# the number of columns each group spans
span = c(1, 2, 2),
# the alignment of each group, can be a single character (lcr) or a vector
align = "c"
)
# first two columns are for GPA (data_grade)
set.seed(2)
b = boot(data = data_grade, statistic = compute_marg_est_boot, R = R,
strata = factor(data_grade$stud_career_degree_name),
output = 'GPA', psw = 'psMw')
df[1,2] = paste(b$t0, '(',round(sd(b$t),3),')')
set.seed(2)
b = boot(data = data_grade, statistic = compute_marg_est_boot, R = R,
strata = factor(data_grade$stud_career_degree_name),
output = 'GPA', psw = 'psRw')
df[2,2] = paste(b$t0, '(',round(sd(b$t),3),')')
# second two columns are for ECTS (data)
set.seed(2)
b = boot(data = data, statistic = compute_marg_est_boot, R = R,
strata = factor(data$stud_career_degree_name),
output = 'ECTS', psw = 'psMw')
source("~/Documents/DATA/POLITECNICO/PHD/Tesi_Ippolito/Tesi_Ippolito/Github/8_matching.R")
source("~/Documents/DATA/POLITECNICO/PHD/Tesi_Ippolito/Tesi_Ippolito/Github/8_matching.R")
source("~/Documents/DATA/POLITECNICO/PHD/Tesi_Ippolito/Tesi_Ippolito/Github/8_matching.R")
rm(list=ls())
library(settings)
reset(options)
graphics.off()
library(nlmeU)  # --> for the dataset
rm(list=ls())
library(settings)
reset(options)
graphics.off()
library(nlmeU)  # --> for the dataset
library(nlme)   # --> for models implementation
library(lattice)
library(corrplot)
library(plot.matrix)
data(armd.wide) # --> wide format
head(armd.wide) # lesion and line0 contain additional information, which we won't use
help(armd.wide)
dim(armd.wide)
str(armd.wide)
data(armd0)     # --> long (or longitudinal) format
head(armd0)     # new features: time.f, time, tp, and visual
help(armd0)
dim(armd0)
str(armd0)
data(armd0)     # --> long (or longitudinal) format
head(armd0)     # new features: time.f, time, tp, and visual
help(armd0)
dim(armd0)
str(armd0)
data(armd)      # --> long (or longitudinal) format (subset of armd0, without baseline)
head(armd)
data(armd.wide) # --> wide format
head(armd.wide) # lesion and line0 contain additional information, which we won't use
help(armd.wide)
data(armd0)     # --> long (or longitudinal) format
head(armd0)     # new features: time.f, time, tp, and visual
help(armd0)
dim(armd0)
str(armd0)
data(armd)      # --> long (or longitudinal) format (subset of armd0, without baseline)
head(armd)
help(armd)
dim(armd)
str(armd)
# armd was built from armd0 as follows:
auxDt <- subset(armd0, time > 0)          # Post-baseline measures
dim(auxDt)                                # No. of rows & cols
levels(auxDt$time.f)                      # Levels of treat.f
armd <- droplevels(auxDt)                 # Drop unused levels
levels(armd$time.f)                       # Baseline level dropped
armd <- within(armd, {                    # Contrasts assigned
contrasts(time.f) <- contr.poly(4, scores = c(4, 12, 24, 52)) # we are changing scores
})
options()$contrasts             # Default contrasts
# factor() or ordered() functions are used to create unordered and ordered factors, respectively.
?factor
options()$contrasts             # Default contrasts
# factor() or ordered() functions are used to create unordered and ordered factors, respectively.
?factor
# Visual-acuity profiles for selected patients --> we visualize same of the trends
armd0.subset <- subset(armd0, as.numeric(subject) %in% seq(1, 240, 5)) # one each 5 patients
xy1 <- xyplot(visual ~ time | treat.f,
# visual and time are plotted against each other in separate
# panels for different values of 'treat.f' factor.
groups = subject,
data = armd0.subset,
type = "l", lty = 1)
update(xy1, xlab = "Time (in weeks)",
ylab = "Visual acuity",
grid = "h")
# The factor miss.pat that indicates which of the four
# post-randomization measurements are missing for a particular patient
table(armd.wide$miss.pat)
# sample means across time and treatment
flst <- list(armd0$time.f, armd0$treat.f)                                     # "By" factors
(tN <-  tapply(armd0$visual, flst, FUN = function(x) length(x[!is.na(x)])))   # Counts
flst
tMn <- tapply(armd0$visual, flst, FUN = mean)     # Sample means
tMd <- tapply(armd0$visual, flst, FUN = median)   # Sample medians
colnames(res  <- cbind(tN, tMn, tMd))             # Column names
nms1 <- rep(c("P", "A"), 3)
nms2 <- rep(c("n", "Mean", "Mdn"), rep(2, 3))
colnames(res) <- paste(nms1, nms2, sep = ":")     # New column names
res
bw1 <- bwplot(visual ~ time.f | treat.f, data = armd0)  # bwplot from package lattice
xlims <- c("Base", "4\nwks", "12\nwks", "24\nwks", "52\nwks")
update(bw1, xlim = xlims, pch = "|")
# measurements for complete cases only (n = 188)
visual.x <- subset(armd.wide, select = c(visual0:visual52))
(varx <- var(visual.x, use = "complete.obs"))            # Var-cov matrix
plot(varx, col=colorRampPalette(c("blue", "white", "red")))
# increase of the variance of visual acuity measurements obtained at later timepoints.
diag(varx)                                               # Var-cov diagonal elements
print(cor(visual.x, use = "complete.obs"), digits = 2)   # Corr matrix
cov2cor(varx)                                            # Corr matrix (alternative way)
plot(cov2cor(varx), col=colorRampPalette(c("blue", "white", "red")))
############################################################################
### 1.1.3 ARMD Trial: Linear Model with Homogeneous Variance (Chapter 6) ###
############################################################################
data(armd, package = "nlmeU")
lm1.form <- formula(visual ~ -1 + time.f + visual0 + treat.f:time.f ) # see 1_2_Formulation_Recap.R
vis.lm1.mf <- model.frame(lm1.form, data = armd)      # Model frame
vis.lm1.dm <- model.matrix(lm1.form, vis.lm1.mf)      # Design matrix X
vis.lm1.dm
dim(vis.lm1.dm)                                       # Dimensions
(nms <- colnames(vis.lm1.dm))                         # Long column names ...
nms <- abbreviate(nms)                                # ... abbreviated
colnames(vis.lm1.dm) <- nms                           # ... assigned.
head(vis.lm1.dm, n = 6)                               # X matrix. Six rows.
attr(vis.lm1.dm, "contrasts")                         # Contrasts attribute (commented above)
contrasts(armd$treat.f)                               # Contrasts for treat.f
# we now fit the linear model
lm6.1 <- lm(lm1.form, data = armd)         # through lm()
lm6.1
summ <- summary(lm6.1)                     # Summary
summ
contrasts(armd$treat.f)                               # Contrasts for treat.f
attr(vis.lm1.dm, "contrasts")                         # Contrasts attribute (commented above)
# How to obtain information from our lm
lm6.1$coefficients       # the betas
lm6.1$residuals          # ^epsilon
lm6.1$rank               # rank
lm6.1$fitted.values      # ^y
lm6.1$df.residual        # degrees of freedom of the model (n-rank)
lm6.1$model              # the dataframe
rstandard(lm6.1)         # the standardized residuals
summ$sigma               # sigma (estimate of the residual standard deviation)
vcov(lm6.1)              # variance-covariance matrix
sqrt(diag(vcov(lm6.1)))  # standard errors of the coefficients
# Plot of the variance-covariance matrix of Y (first 8 observations)
# --> it is a diagonal matrix with a value of 12.38^2
par(mar = c(4,4,4,4))
plot(diag(x=12.38^2, nrow=8, ncol=8),
col=colorRampPalette(c("blue", "white", "red")),
main='Variance-covariance matrix of Y')
# Confidence intervals for the coefficients
alpha=0.05
confint(lm6.1,level = 1 - alpha)
# We can correct them through Bonferroni
confint(lm6.1,level = 1 - alpha/length(lm6.1$coefficients))
# Step 1: we generate new observations (within the range of the observed values)
X.new <- data.frame(time.f = ordered(rep(c('4wks', '12wks', '24wks', '52wks' ),3)),
visual0 = c(rep(50,4), rep(60,4), rep(55,4)),
treat.f = factor(c(rep('Active',4), rep('Placebo',4), rep('Active',4)))
)
X.new
# Step 2: we build the intervals (for each single observation)
IC <-predict(lm6.1, X.new, interval="confidence", level=0.95)
IC
IP <-predict(lm6.1, X.new, interval="prediction", level=0.95)
IP
?predict.lm
anova(lm6.1)                               # ANOVA table
# Comment #1
# NB. p-value for the F-test for time.f:treat.f is significant (at the 5%)
# --> presence of a time-varying treatment effect.
summary(lm6.1)
lm1.form2 <- formula(visual ~ -1 + visual0 + time.f)
# Comment #1
# NB. p-value for the F-test for time.f:treat.f is significant (at the 5%)
# --> presence of a time-varying treatment effect.
summary(lm6.1)
anova(lm6.1)                               # ANOVA table
# Comment #1
# NB. p-value for the F-test for time.f:treat.f is significant (at the 5%)
# --> presence of a time-varying treatment effect.
summary(lm6.1)
anova(lm6.1)                               # ANOVA table
lm1.form <- formula(visual ~ -1 + visual0 + time.f + treat.f:time.f ) # see 1_2_Formulation_Recap.R
vis.lm1.mf <- model.frame(lm1.form, data = armd)      # Model frame
vis.lm1.dm <- model.matrix(lm1.form, vis.lm1.mf)      # Design matrix X
vis.lm1.dm
dim(vis.lm1.dm)                                       # Dimensions
(nms <- colnames(vis.lm1.dm))                         # Long column names ...
nms <- abbreviate(nms)                                # ... abbreviated
colnames(vis.lm1.dm) <- nms                           # ... assigned.
head(vis.lm1.dm, n = 6)                               # X matrix. Six rows.
attr(vis.lm1.dm, "contrasts")                         # Contrasts attribute (commented above)
contrasts(armd$treat.f)                               # Contrasts for treat.f
# we now fit the linear model
lm6.1 <- lm(lm1.form, data = armd)         # through lm()
lm6.1
summ <- summary(lm6.1)                     # Summary
summ
# How to obtain information from our lm
lm6.1$coefficients       # the betas
lm6.1$residuals          # ^epsilon
lm6.1$rank               # rank
lm6.1$fitted.values      # ^y
lm6.1$df.residual        # degrees of freedom of the model (n-rank)
lm6.1$model              # the dataframe
rstandard(lm6.1)         # the standardized residuals
summ$sigma               # sigma (estimate of the residual standard deviation)
vcov(lm6.1)              # variance-covariance matrix
sqrt(diag(vcov(lm6.1)))  # standard errors of the coefficients
# Plot of the variance-covariance matrix of Y (first 8 observations)
# --> it is a diagonal matrix with a value of 12.38^2
par(mar = c(4,4,4,4))
plot(diag(x=12.38^2, nrow=8, ncol=8),
col=colorRampPalette(c("blue", "white", "red")),
main='Variance-covariance matrix of Y')
# Confidence intervals for the coefficients
alpha=0.05
confint(lm6.1,level = 1 - alpha)
# We can correct them through Bonferroni
confint(lm6.1,level = 1 - alpha/length(lm6.1$coefficients))
# Step 1: we generate new observations (within the range of the observed values)
X.new <- data.frame(time.f = ordered(rep(c('4wks', '12wks', '24wks', '52wks' ),3)),
visual0 = c(rep(50,4), rep(60,4), rep(55,4)),
treat.f = factor(c(rep('Active',4), rep('Placebo',4), rep('Active',4)))
)
X.new
# Step 2: we build the intervals (for each single observation)
IC <-predict(lm6.1, X.new, interval="confidence", level=0.95)
IC
IP <-predict(lm6.1, X.new, interval="prediction", level=0.95)
IP
?predict.lm
anova(lm6.1)                               # ANOVA table
# Comment #1
# NB. p-value for the F-test for time.f:treat.f is significant (at the 5%)
# --> presence of a time-varying treatment effect.
summary(lm6.1)
lm1.form2 <- formula(visual ~ -1 + visual0 + time.f)
lm6.1_2 <- lm(lm1.form2, data = armd)         # through lm()
summ2 <- summary(lm6.1_2)                     # Summary
summ2
anova(lm6.1_2, lm6.1)                         # fm6.1_2 nested in fm6.1
library(car)
# 1. the variable treat.f
linearHypothesis(lm6.1,
rbind(c(0,0,0,0,0,1,0,0,0),
c(0,0,0,0,0,0,1,0,0),
c(0,0,0,0,0,0,0,1,0),
c(0,0,0,0,0,0,0,0,1)),
c(0,0,0,0))
# 2. the variable time.f
linearHypothesis(lm6.1,
rbind(c(0,1,0,0,0,0,0,0,0),
c(0,0,1,0,0,0,0,0,0),
c(0,0,0,1,0,0,0,0,0),
c(0,0,0,0,1,0,0,0,0),
c(0,0,0,0,0,1,0,0,0),
c(0,0,0,0,0,0,1,0,0),
c(0,0,0,0,0,0,0,1,0),
c(0,0,0,0,0,0,0,0,1)),
c(0,0,0,0,0,0,0,0))
# 3. the effect of the variable time.f on the intercept
linearHypothesis(lm6.1,
rbind(c(0,1,0,0,0,0,0,0,0),
c(0,0,1,0,0,0,0,0,0),
c(0,0,0,1,0,0,0,0,0),
c(0,0,0,0,1,0,0,0,0)),
c(0,0,0,0))
# Hypothesis testing
# is it necessary to include in the model:...?
# 1. the variable treat.f;
# 2. the variable time.f;
# 3. the effect of the variable time.f on the intercept.
summary(lm6.1)
# Diagnostics plots
# Scatterplot of raw residuals versus fitted values
x11()
plot(fitted(lm6.1), residuals(lm6.1)) #residuals() can be replaced by resid() or lm6.1$residuals
x11()
plot(fitted(lm6.1), residuals(lm6.1)) #residuals() can be replaced by resid() or lm6.1$residuals
abline(h = seq(-40, 40, by = 20), col = "grey")
abline(v = seq( 10, 80, by = 10), col = "grey")
x11()
